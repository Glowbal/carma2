{"name":"Carma2","tagline":"A thinline object parser/translator for RV SQF offering a prototyped object system with automatic, unintrusive garbage collecting memory management.","body":"# carma2\r\n\r\nA thinline object parser/translator for RV SQF offering a prototyped object system with automatic, unintrusive garbage collecting memory management.\r\n\r\nGithub: https://github.com/NouberNou/carma2\r\n\r\nThe only dependency is [CBA](https://github.com/CBATeam/CBA_A3).\r\n\r\n## Concept\r\n\r\nThe concept of carma2 is to add a very low overhead, very simple object implementation in SQF. The focus is on maintaining as many paradigms with SQF as possible, so as to not create too much of a disassociation with base SQF.\r\n\r\nImplementation of objects is done in a very simple fashion that ultimately is closer to syntactic sugar than it is a \"proper\" object implementation, but through the help of helpers provides a robust object system. Objects are created using the `new` keyword and members and methods are accessed using the `.` operator and assigned/defined using the standard SQF `=` operator. The only major difference is that method invocation is done using `()` following the method name, instead of the standard SQF `arg call function` format (though it is entirely possible to invoke methods this way, though with some caveats). \r\n\r\nA simple carma2 example is below:\r\n```\r\n_testObject = new carma2_object(); // create a new object from the default carma2_base object\r\n_testObject.myMethod = { player sideChat \"hello world!\"; };\r\n_testObject.myMethod(); // calls myMethod and displays \"hello world!\"\r\n```\r\n\r\nMethod parameters can be accessed via the normal `_this` variable.\r\n\r\nObjects as such then are defined as they are created, similar to the Javascript prototype system. As such creating a new object of an existing type is as easy as follows:\r\n\r\n```\r\n// using the code from above\r\n_anotherTestObject = new _testObject();\r\n_anotherTestObject.myMethod(); // calls myMethod on this new object.\r\n```\r\n\r\nObjects will copy their members (but will **not** copy their values) to the new object, and copy their methods as well. This means that you can easily define and create new objects. Type checking can be done via the special `__prototype` member in every object, which will contain the object that `new` was called on. Introspection can be achieved via using the normal `allVariables` SQF command on an object (carma2 objects are implemented as location objects, which have no in-game overhead).\r\n\r\nMethod definitions can access their calling object via the `_thisObj` variable.\r\n\r\nFor example:\r\n```\r\n_testObject = new carma2_object(); // create a new object from the default carma2_base object\r\n_testObject.myMethod = { player sideChat format[\"myVal: %1\", _thisObj.myVal]; };\r\n_testObject.myVal = 2;\r\n_testObject.myMethod(); // calls myMethod and displays \"myVal: 2\"\r\n```\r\n\r\nObjects can call a constructor like function on creation by assigning the special method `__init`. There are no destructors in carma2 as the system uses a garbage collecting reference tracker. Implementation of a special method for when the object is garbage collected (or the `del` keyword is used) is forthcoming, though programmers using carma2 should make sure to smartly implement resources that need to be freed in a way that is not dependent on the lifespan of the object.\r\n\r\n## Performance\r\n\r\nA often run into drawback with object oriented systems in SQF are the overhead that objects introduce, either through their programmatic implementation or through their in engine implementation. In carma2, the language strives to be as close as possible to the engine, to minimize overhead. To do this carma2 utilizes the native `setVariable` and `getVariable` SQF functions on native SQF objects, which in this case are [locations](https://community.bistudio.com/wiki/createLocation). Locations in SQF add no apparent overhead to game performance, and are simply resident in the SQF engine's memory. As such, tens of thousands of them can be initiated with no performance impact. This is already being utilized in projects such as ACRE for implementing a fast, SQF native hash-map implementation.\r\n\r\nBecause of this member variable access is a simple call to `getVariable`. Assignments are a simple call to `setVariable`. Invoking a method simply calls a wrapper function that creates the `_thisObj` special variable and then calls the arguments on a `getVariable` call. Overhead on method invocation is as little as `0.0077ms`, and default single member access is often a third of that. This provides almost native SQF level speeds.\r\n\r\n## Usage\r\n\r\nUsing carma2 is very simple. Launch with the mod enabled/included, as well as CBA.\r\n\r\nA simple usage example is here:\r\n```\r\n#include \"\\x\\carma2\\rv\\addons\\lib\\carma.hpp\"\r\n\r\nCARMA_COMPILE(\"test.sqf\");\r\n```\r\n\r\nThat code will compile and load the file `test.sqf`. You can then access any globally defined objects compiled in there.\r\n\r\nThe `CARMA_COMPILE` macro is a macro to `carma2_fnc_compile`. If you just wish to compile your code with out executing it (not often the case), you can pass an optional `false` argument. The compilation function will return the compiled results either way.\r\n\r\n## Advanced Concepts\r\n\r\n###Pseudo-static Members with :: Operator\r\n\r\nUsing the `::` operator you can easily access a objects prototype members/methods, the same as above using the `__prototype` member.\r\n\r\nSince all objects that descend from a common prototype share the same instance of that prototype you can use it to define static methods/members that will be shared across all classes.\r\n\r\n```\r\ntest_base = new carma2_object(); // this will be our prototype.\r\n\r\ntest_base.staticMember = 123; // assign the prototype object a member var\r\n\r\ntest_instance1 = new test_base();\r\ntest_instance2 = new test_base();\r\n\r\nplayer sideChat format[\"test_instance1: %1\", test_instance1::staticMember]; // prints 123\r\n\r\ntest_instance1::staticMember = 321; // assign the static variable on test_instance1 to 321\r\n\r\nplayer sideChat format[\"test_instance2: %1\", test_instance2::staticMember]; // print the static variable on test_instance2, prints 321\r\n```\r\n\r\n###Chaining\r\n\r\nChaining members with the `.` or the `::` operator is allowed if they are also objects (if they are not, undefined RPT errors may occur).\r\n```\r\n_var = _testObject.myMemberObject.anotherMember; // accessing a members member.\r\n_testObject.myMemberObject.someMethod(1,2,3); // invoking a members method.\r\n\r\n_var = _testObject::myStaticMember::anotherStaticMember; // accessing a static objects member.\r\n_testObject::myStaticObject::someStaticMethod(1,2,3); // invoking a static object's method.\r\n```\r\n\r\nChaining methods is also supported:\r\n```\r\n_testObject = new carma2_object();\r\n_testObject.hello = { player sideChat \"hello\"; _thisObj; };\r\n_testObject.world = { player sideChat \"world\"; _thisObj; };\r\n_testObject.hello().world(); // prints \"hello\" and then prints \"world\"\r\n```\r\n\r\n###Calling Overriden Methods\r\n\r\nCalling the original overridden methods is done via accessing the objects prototype object definition, either through the `::` operator, or the `__prototype` member, and then using the magic methods `__call(context, arg1, arg2, ...)` or `__apply(context, arg_array)`. These methods execute the desired overriden/parent method in a supplied context, commonly passing `_thisObj` to the method, along with the methods arguments.\r\n\r\nAn example is given below demonstrating the usage of the `__call` and `__apply` functions.\r\n\r\n```\r\ntest_base = new carma2_object();\r\ntest_base.testVal = \"base instance\";\r\ntest_base.parentMethod = {\r\n    diag_log text format[\"Object %1: %2, %3\", _thisObj.__id, _thisObj.testVal, _this];\r\n};\r\n\r\ntest_instance = new test_base();\r\ntest_instance.testVal = \"child instance\";\r\n\r\ntest_instance.testMethod = {\r\n    // call the prototype method, in the context of the prototype, essentially a static method.\r\n    _thisObj::parentMethod(1);\r\n    \r\n    // call the prototype method, but in the context of this instance using __call(context, arg1, arg2, ...)\r\n    _thisObj::parentMethod.__call(_thisObj, 2);\r\n    \r\n    // call the prototype method, but using __apply(context, arg_array)\r\n    _args = [3];\r\n    _thisObj::parentMethod.__apply(_thisObj, _args);\r\n};\r\n\r\ntest_instance.testMethod();\r\n```\r\n\r\nThis prints to the RPT:\r\n```\r\nObject 1: base instance, [1]\r\nObject 2: child instance, [2]\r\nObject 2: child instance, [3]\r\n```\r\n\r\nAn example of overridden method calling it's parent method is below.\r\n\r\n```\r\ntest_base = new carma2_object();\r\ntest_base.testVal = \"base instance\";\r\ntest_base.testVal = 0;\r\ntest_base.testMethod = {\r\n    diag_log text format[\"parent: %1 testVal: %2\", _this[0], _thisObj.testVal];\r\n};\r\n\r\ntest_instance = new test_base();\r\ntest_instance.testVal = 999;\r\ntest_instance.testMethod = {\r\n    _thisObj::testMethod(333); // call the parent method as a static method, the context is the __prototype object.\r\n    _thisObj::testMethod.__call(_thisObj, _this[0]); // call takes the args to the function in-situ after the context object\r\n    _thisObj::testMethod.__apply(_thisObj, _this); // apply takes the args as an array\r\n    diag_log text format[\"child: %1 testVal: %2\", _this[0], _thisObj.testVal];\r\n};\r\n\r\ntest_instance.testMethod(123);\r\n```\r\n\r\nResults in:\r\n```\r\nparent: 333 testVal: 0\r\nparent: 123 testVal: 999\r\nparent: 123 testVal: 999\r\nchild: 123 testVal: 999\r\n```\r\n\r\n###Anonymous Objects\r\n\r\nPassing an object to a SQF function or a carma2 object method can be done anonymously via the `new` keyword.\r\n```\r\n[new someObject()] call some_sqf_fnc;\r\n_myObject.method(new subObject());\r\n```\r\n\r\n###Array [] Accessors\r\n\r\nArrays can now be accessed and manipulated via the more traditional `[]` operator as in other languages.\r\n\r\n```\r\n_testObject = new carma2_object();\r\n\r\n_testObject.myArray = [1,2,3];\r\nplayer sideChat format[\"_testObject.myArray[0] = %1\", _testObject.myArray[0]]; // access via the [] operator\r\n\r\n_testObject.myArray[0] = 2; // assign via the [] operator.\r\nplayer sideChat format[\"_testObject.myArray[0] = %1\", _testObject.myArray[0]];\r\n\r\n_testObject.getArray = {\r\n    _thisObj.myArray;\r\n};\r\n_testObject.getArray()[0] = 3; // assign via reference return.\r\n\r\nplayer sideChat format[\"_testObject.myArray[0] = %1\", _testObject.getArray()[0]]; //access via reference return\r\n```\r\n\r\nArrays on their own can be accessed via the `[]` operator as well.\r\n\r\n```\r\n_testArray = [1,2,3];\r\nplayer sideChat format[\"Test array: %1\", _testArray[1]];\r\n_testArray[1] = 48;\r\nplayer sideChat format[\"Test array: %1\", _testArray[1]];\r\n```\r\n\r\n###Traditional Function Calling\r\n\r\nYou can call any SQF defined function the same as you would in most languages using parenthesis.\r\n\r\n```\r\nmy_func = { player sideChat format[\"this: %1\", _this]; };\r\nmy_func(1,2,3); // prints \"this: [1,2,3]\"\r\n```\r\n\r\n###String Member Accesor {}\r\n\r\nUsing the `{}` operator you can access member variables using strings.\r\n```\r\ntest.member = 123;\r\n_val = test{\"member\"}; // assigns 123;\r\ntest{\"member\"} = 321; // reassign using string accessor;\r\n```\r\n\r\nThis functionally turns objects into a hash map (they are internally in carma2, and in the engine represented as a hash map anyways, so this makes sense).\r\n\r\nBecause of this, carma2 comes with a default hash map object, `carma2_hashmap`. An example is provided below:\r\n```\r\n_testHash = new carma2_hashmap();\r\n_testHash{\"key1\"} = 123;\r\n_testHash{\"key2\"} = 321;\r\n_testHash{\"key3\"} = 999;\r\n\r\n{\r\n    player sideChat format[\"%1: %2\", _x, _testHash{_x}];\r\n} forEach _testHash._keys();\r\n```\r\n\r\nBeyond the `carma2_hashmap._keys()` method show above there is also a `carma2_hashmap._hasKey(keyname)` and `carma2_hashmap._delete(key)` function as well. More documentation on this and other default objects will come in the wiki at some point in the future.\r\n\r\n## Additional Features\r\n\r\n### Critical Sections\r\n\r\nBy including `\\x\\carma2\\rv\\addons\\lib\\carma.hpp` in your script (always a good idea) you can access the helper macros `carma2_start_crit_section` and `carma2_end_crit_section`. These allow you to add critical execution phases in a scheduled environment. That is, code between `carma2_start_crit_section` and `carma2_end_crit_section` will be executed in a blocking fashion, guaranteeing that the code will execute in sequence, and no other code will execute until it is finished.\r\n\r\n```\r\n#include \"\\x\\carma2\\rv\\addons\\lib\\carma.hpp\"\r\n\r\n[] spawn {\r\n    _testVar = \"123\";\r\n    carma2_start_crit_section;\r\n    for \"_i\" from 0 to 10000 do {\r\n        diag_log text format[\"poop: %1 %2\", _testVar, _thisScript];\r\n    };\r\n    carma2_end_crit_section;\r\n};\r\n```\r\n\r\nBe aware that code inside a critical section is considered its own scope, so while variables will transfer into it (including `_this`), local variables that are only declared inside of it will not leave the critical section. Define any variables you wish to manipulate inside the critical section before the critical section executes.\r\n\r\nCritical sections work by abusing the condition statement in the SQF command [`configClasses`](https://community.bistudio.com/wiki/configClasses) which executes in a blocking fashion.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}